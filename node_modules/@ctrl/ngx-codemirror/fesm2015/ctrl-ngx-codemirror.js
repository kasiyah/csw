import { __decorate, __metadata } from 'tslib';
import { EventEmitter, KeyValueDiffers, NgZone, Input, Output, ViewChild, ElementRef, Component, forwardRef, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

var CodemirrorComponent_1;
function normalizeLineEndings(str) {
    if (!str) {
        return str;
    }
    return str.replace(/\r\n|\r/g, '\n');
}
/* tslint:disable */
var CodeMirror;
/* tslint:enable */
let CodemirrorComponent = CodemirrorComponent_1 = class CodemirrorComponent {
    constructor(_differs, _ngZone) {
        this._differs = _differs;
        this._ngZone = _ngZone;
        /* class applied to the created textarea */
        this.className = '';
        /* name applied to the created textarea */
        this.name = 'codemirror';
        /* autofocus setting applied to the created textarea */
        this.autoFocus = false;
        /* preserve previous scroll position after updating value */
        this.preserveScrollPosition = false;
        /* called when the text cursor is moved */
        this.cursorActivity = new EventEmitter();
        /* called when the editor is focused or loses focus */
        this.focusChange = new EventEmitter();
        /* called when the editor is scrolled */
        this.scroll = new EventEmitter();
        /* called when file(s) are dropped */
        this.drop = new EventEmitter();
        this.value = '';
        this.disabled = false;
        this.isFocused = false;
        /** Implemented as part of ControlValueAccessor. */
        this.onChange = (_) => { };
        /** Implemented as part of ControlValueAccessor. */
        this.onTouched = () => { };
    }
    /**
     * set options for codemirror
     * @link http://codemirror.net/doc/manual.html#config
     */
    set options(value) {
        this._options = value;
        if (!this._differ && value) {
            this._differ = this._differs.find(value).create();
        }
    }
    get codeMirrorGlobal() {
        if (this._codeMirror) {
            return this._codeMirror;
        }
        this._codeMirror = CodeMirror ? CodeMirror : require('codemirror');
        return this._codeMirror;
    }
    ngAfterViewInit() {
        if (!this.ref) {
            return;
        }
        // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
        this._ngZone.runOutsideAngular(() => {
            this.codeMirror = this.codeMirrorGlobal.fromTextArea(this.ref.nativeElement, this._options);
            this.codeMirror.on('cursorActivity', cm => this._ngZone.run(() => this.cursorActive(cm)));
            this.codeMirror.on('scroll', this.scrollChanged.bind(this));
            this.codeMirror.on('blur', () => this._ngZone.run(() => this.focusChanged(false)));
            this.codeMirror.on('focus', () => this._ngZone.run(() => this.focusChanged(true)));
            this.codeMirror.on('change', (cm, change) => this._ngZone.run(() => this.codemirrorValueChanged(cm, change)));
            this.codeMirror.on('drop', (cm, e) => {
                this._ngZone.run(() => this.dropFiles(cm, e));
            });
            this.codeMirror.setValue(this.value);
        });
    }
    ngDoCheck() {
        if (!this._differ) {
            return;
        }
        // check options have not changed
        const changes = this._differ.diff(this._options);
        if (changes) {
            changes.forEachChangedItem(option => this.setOptionIfChanged(option.key, option.currentValue));
            changes.forEachAddedItem(option => this.setOptionIfChanged(option.key, option.currentValue));
            changes.forEachRemovedItem(option => this.setOptionIfChanged(option.key, option.currentValue));
        }
    }
    ngOnDestroy() {
        // is there a lighter-weight way to remove the cm instance?
        if (this.codeMirror) {
            this.codeMirror.toTextArea();
        }
    }
    codemirrorValueChanged(cm, change) {
        if (change.origin !== 'setValue') {
            this.value = cm.getValue();
            this.onChange(this.value);
        }
    }
    setOptionIfChanged(optionName, newValue) {
        if (!this.codeMirror) {
            return;
        }
        // cast to any to handle strictly typed option names
        // could possibly import settings strings available in the future
        this.codeMirror.setOption(optionName, newValue);
    }
    focusChanged(focused) {
        this.onTouched();
        this.isFocused = focused;
        this.focusChange.emit(focused);
    }
    scrollChanged(cm) {
        this.scroll.emit(cm.getScrollInfo());
    }
    cursorActive(cm) {
        this.cursorActivity.emit(cm);
    }
    dropFiles(cm, e) {
        this.drop.emit([cm, e]);
    }
    /** Implemented as part of ControlValueAccessor. */
    writeValue(value) {
        if (value === null || value === undefined) {
            return;
        }
        if (!this.codeMirror) {
            this.value = value;
            return;
        }
        const cur = this.codeMirror.getValue();
        if (value !== cur &&
            normalizeLineEndings(cur) !== normalizeLineEndings(value)) {
            this.value = value;
            if (this.preserveScrollPosition) {
                const prevScrollPosition = this.codeMirror.getScrollInfo();
                this.codeMirror.setValue(this.value);
                this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
            }
            else {
                this.codeMirror.setValue(this.value);
            }
        }
    }
    /** Implemented as part of ControlValueAccessor. */
    registerOnChange(fn) {
        this.onChange = fn;
    }
    /** Implemented as part of ControlValueAccessor. */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /** Implemented as part of ControlValueAccessor. */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.setOptionIfChanged('readOnly', this.disabled);
    }
};
CodemirrorComponent.ctorParameters = () => [
    { type: KeyValueDiffers },
    { type: NgZone }
];
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "className", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "autoFocus", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], CodemirrorComponent.prototype, "options", null);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "preserveScrollPosition", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "cursorActivity", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "focusChange", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "scroll", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], CodemirrorComponent.prototype, "drop", void 0);
__decorate([
    ViewChild('ref', { static: true }),
    __metadata("design:type", ElementRef)
], CodemirrorComponent.prototype, "ref", void 0);
CodemirrorComponent = CodemirrorComponent_1 = __decorate([
    Component({
        selector: 'ngx-codemirror',
        template: `
    <textarea
      [name]="name"
      class="ngx-codemirror {{ className }}"
      [class.ngx-codemirror--focused]="isFocused"
      autocomplete="off"
      [autofocus]="autoFocus"
      #ref
    >
    </textarea>
  `,
        providers: [
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => CodemirrorComponent_1),
                multi: true,
            },
        ],
        preserveWhitespaces: false,
        changeDetection: ChangeDetectionStrategy.OnPush
    }),
    __metadata("design:paramtypes", [KeyValueDiffers, NgZone])
], CodemirrorComponent);

let CodemirrorModule = class CodemirrorModule {
};
CodemirrorModule = __decorate([
    NgModule({
        exports: [CodemirrorComponent],
        declarations: [CodemirrorComponent],
    })
], CodemirrorModule);

/**
 * Generated bundle index. Do not edit.
 */

export { CodemirrorComponent, CodemirrorModule };
//# sourceMappingURL=ctrl-ngx-codemirror.js.map
