import { __decorate, __metadata } from 'tslib';
import { EventEmitter, KeyValueDiffers, NgZone, Input, Output, ViewChild, ElementRef, Component, forwardRef, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

function normalizeLineEndings(str) {
    if (!str) {
        return str;
    }
    return str.replace(/\r\n|\r/g, '\n');
}
/* tslint:disable */
var CodeMirror;
/* tslint:enable */
var CodemirrorComponent = /** @class */ (function () {
    function CodemirrorComponent(_differs, _ngZone) {
        this._differs = _differs;
        this._ngZone = _ngZone;
        /* class applied to the created textarea */
        this.className = '';
        /* name applied to the created textarea */
        this.name = 'codemirror';
        /* autofocus setting applied to the created textarea */
        this.autoFocus = false;
        /* preserve previous scroll position after updating value */
        this.preserveScrollPosition = false;
        /* called when the text cursor is moved */
        this.cursorActivity = new EventEmitter();
        /* called when the editor is focused or loses focus */
        this.focusChange = new EventEmitter();
        /* called when the editor is scrolled */
        this.scroll = new EventEmitter();
        /* called when file(s) are dropped */
        this.drop = new EventEmitter();
        this.value = '';
        this.disabled = false;
        this.isFocused = false;
        /** Implemented as part of ControlValueAccessor. */
        this.onChange = function (_) { };
        /** Implemented as part of ControlValueAccessor. */
        this.onTouched = function () { };
    }
    CodemirrorComponent_1 = CodemirrorComponent;
    Object.defineProperty(CodemirrorComponent.prototype, "options", {
        /**
         * set options for codemirror
         * @link http://codemirror.net/doc/manual.html#config
         */
        set: function (value) {
            this._options = value;
            if (!this._differ && value) {
                this._differ = this._differs.find(value).create();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CodemirrorComponent.prototype, "codeMirrorGlobal", {
        get: function () {
            if (this._codeMirror) {
                return this._codeMirror;
            }
            this._codeMirror = CodeMirror ? CodeMirror : require('codemirror');
            return this._codeMirror;
        },
        enumerable: true,
        configurable: true
    });
    CodemirrorComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!this.ref) {
            return;
        }
        // in order to allow for universal rendering, we import Codemirror runtime with `require` to prevent node errors
        this._ngZone.runOutsideAngular(function () {
            _this.codeMirror = _this.codeMirrorGlobal.fromTextArea(_this.ref.nativeElement, _this._options);
            _this.codeMirror.on('cursorActivity', function (cm) {
                return _this._ngZone.run(function () { return _this.cursorActive(cm); });
            });
            _this.codeMirror.on('scroll', _this.scrollChanged.bind(_this));
            _this.codeMirror.on('blur', function () {
                return _this._ngZone.run(function () { return _this.focusChanged(false); });
            });
            _this.codeMirror.on('focus', function () {
                return _this._ngZone.run(function () { return _this.focusChanged(true); });
            });
            _this.codeMirror.on('change', function (cm, change) {
                return _this._ngZone.run(function () { return _this.codemirrorValueChanged(cm, change); });
            });
            _this.codeMirror.on('drop', function (cm, e) {
                _this._ngZone.run(function () { return _this.dropFiles(cm, e); });
            });
            _this.codeMirror.setValue(_this.value);
        });
    };
    CodemirrorComponent.prototype.ngDoCheck = function () {
        var _this = this;
        if (!this._differ) {
            return;
        }
        // check options have not changed
        var changes = this._differ.diff(this._options);
        if (changes) {
            changes.forEachChangedItem(function (option) {
                return _this.setOptionIfChanged(option.key, option.currentValue);
            });
            changes.forEachAddedItem(function (option) {
                return _this.setOptionIfChanged(option.key, option.currentValue);
            });
            changes.forEachRemovedItem(function (option) {
                return _this.setOptionIfChanged(option.key, option.currentValue);
            });
        }
    };
    CodemirrorComponent.prototype.ngOnDestroy = function () {
        // is there a lighter-weight way to remove the cm instance?
        if (this.codeMirror) {
            this.codeMirror.toTextArea();
        }
    };
    CodemirrorComponent.prototype.codemirrorValueChanged = function (cm, change) {
        if (change.origin !== 'setValue') {
            this.value = cm.getValue();
            this.onChange(this.value);
        }
    };
    CodemirrorComponent.prototype.setOptionIfChanged = function (optionName, newValue) {
        if (!this.codeMirror) {
            return;
        }
        // cast to any to handle strictly typed option names
        // could possibly import settings strings available in the future
        this.codeMirror.setOption(optionName, newValue);
    };
    CodemirrorComponent.prototype.focusChanged = function (focused) {
        this.onTouched();
        this.isFocused = focused;
        this.focusChange.emit(focused);
    };
    CodemirrorComponent.prototype.scrollChanged = function (cm) {
        this.scroll.emit(cm.getScrollInfo());
    };
    CodemirrorComponent.prototype.cursorActive = function (cm) {
        this.cursorActivity.emit(cm);
    };
    CodemirrorComponent.prototype.dropFiles = function (cm, e) {
        this.drop.emit([cm, e]);
    };
    /** Implemented as part of ControlValueAccessor. */
    CodemirrorComponent.prototype.writeValue = function (value) {
        if (value === null || value === undefined) {
            return;
        }
        if (!this.codeMirror) {
            this.value = value;
            return;
        }
        var cur = this.codeMirror.getValue();
        if (value !== cur &&
            normalizeLineEndings(cur) !== normalizeLineEndings(value)) {
            this.value = value;
            if (this.preserveScrollPosition) {
                var prevScrollPosition = this.codeMirror.getScrollInfo();
                this.codeMirror.setValue(this.value);
                this.codeMirror.scrollTo(prevScrollPosition.left, prevScrollPosition.top);
            }
            else {
                this.codeMirror.setValue(this.value);
            }
        }
    };
    /** Implemented as part of ControlValueAccessor. */
    CodemirrorComponent.prototype.registerOnChange = function (fn) {
        this.onChange = fn;
    };
    /** Implemented as part of ControlValueAccessor. */
    CodemirrorComponent.prototype.registerOnTouched = function (fn) {
        this.onTouched = fn;
    };
    /** Implemented as part of ControlValueAccessor. */
    CodemirrorComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
        this.setOptionIfChanged('readOnly', this.disabled);
    };
    var CodemirrorComponent_1;
    CodemirrorComponent.ctorParameters = function () { return [
        { type: KeyValueDiffers },
        { type: NgZone }
    ]; };
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "className", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "name", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "autoFocus", void 0);
    __decorate([
        Input(),
        __metadata("design:type", Object),
        __metadata("design:paramtypes", [Object])
    ], CodemirrorComponent.prototype, "options", null);
    __decorate([
        Input(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "preserveScrollPosition", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "cursorActivity", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "focusChange", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "scroll", void 0);
    __decorate([
        Output(),
        __metadata("design:type", Object)
    ], CodemirrorComponent.prototype, "drop", void 0);
    __decorate([
        ViewChild('ref', { static: true }),
        __metadata("design:type", ElementRef)
    ], CodemirrorComponent.prototype, "ref", void 0);
    CodemirrorComponent = CodemirrorComponent_1 = __decorate([
        Component({
            selector: 'ngx-codemirror',
            template: "\n    <textarea\n      [name]=\"name\"\n      class=\"ngx-codemirror {{ className }}\"\n      [class.ngx-codemirror--focused]=\"isFocused\"\n      autocomplete=\"off\"\n      [autofocus]=\"autoFocus\"\n      #ref\n    >\n    </textarea>\n  ",
            providers: [
                {
                    provide: NG_VALUE_ACCESSOR,
                    useExisting: forwardRef(function () { return CodemirrorComponent_1; }),
                    multi: true,
                },
            ],
            preserveWhitespaces: false,
            changeDetection: ChangeDetectionStrategy.OnPush
        }),
        __metadata("design:paramtypes", [KeyValueDiffers, NgZone])
    ], CodemirrorComponent);
    return CodemirrorComponent;
}());

var CodemirrorModule = /** @class */ (function () {
    function CodemirrorModule() {
    }
    CodemirrorModule = __decorate([
        NgModule({
            exports: [CodemirrorComponent],
            declarations: [CodemirrorComponent],
        })
    ], CodemirrorModule);
    return CodemirrorModule;
}());

/**
 * Generated bundle index. Do not edit.
 */

export { CodemirrorComponent, CodemirrorModule };
//# sourceMappingURL=ctrl-ngx-codemirror.js.map
